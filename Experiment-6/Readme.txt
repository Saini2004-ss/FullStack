6.1 Create an Express.js server and implement two custom middleware functions. The first middleware should log the HTTP method, request URL, and timestamp for every incoming request. The second middleware should check for an Authorization header that includes a Bearer token. Only requests that include the token mysecrettoken should be allowed to access the protected route; all other requests should be denied with appropriate error messages. Apply the logging middleware globally to all routes. Create at least two routes: one public route accessible without authentication, and one protected route that requires the correct Bearer token (mysecrettoken) to access. Test both routes using curl or Postman to demonstrate how logging and token-based authentication work together.

6.2 Create an Express.js banking API with endpoints for viewing account balance (/balance), depositing money (/deposit), and withdrawing money (/withdraw). Implement a /login route that accepts a username and password (hardcoded for this exercise) and returns a signed JWT token upon successful login. Use a middleware function to verify the JWT token in the Authorization header before allowing access to the protected banking routes. Handle common errors, such as missing or invalid tokens and insufficient balance for withdrawals. Test the API by first logging in to obtain a token, then sending it as a Bearer token in requests to protected endpoints to demonstrate secure access control.

6.3 Create a Node.js and Express.js application with a MongoDB database to simulate a bank account transfer system. Implement an API endpoint to transfer money from one user account to another. Before updating balances, check if the sender has enough balance and proceed only if the condition is satisfied. Even though database-level transactions are not used, ensure logical correctness through proper validation and sequential updates. Return meaningful error messages when the sender's balance is insufficient or if either account does not exist. Test the API using sample user accounts, and demonstrate both successful and failed transfer scenarios to show how logical checks prevent invalid state updates.